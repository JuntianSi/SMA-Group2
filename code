#Import the required packages

import simpy
import random
import numpy as np
import math


global N, nr_servers, env

env = simpy.Environment()
# Define the number of scans to process
N = 1000

# Define the number of servers for each workstation
nr_servers = {
    0: 3,  # Number of servers for workstation 0
    1: 2,  # Number of servers for workstation 1
    2: 4,  # Number of servers for workstation 2
    3: 3,  # Number of servers for workstation 3
    4: 1   # Number of servers for workstation 4
}

np.random.seed(1234)

lamb = [1/0.25, 1/1] #Arrival rates

def Exponential_distribution(lambdaValue):
    return np.random.exponential(scale=1/lambdaValue)

def InterArrival_R():
    return Exponential_distribution(lamb[0])

def InterArrival_D():
    return Exponential_distribution(lamb[1])

def JobType(probabilities):
    return np.random.choice(np.arange(1, 5), p=probabilities)

jobtype_R_probabilities = [0.2, 0.2, 0.1, 0.5]
jobtype_D_probabilities = [0, 0.4, 0, 0.6]

jobtype_R = JobType(jobtype_R_probabilities)
jobtype_D = JobType(jobtype_D_probabilities)


class Scan:
    def __init__(self, arrival_time: float, scan_type: int, scan_id: int) -> None:
        if arrival_time < 0:
            raise ValueError("arrival_time cannot be negative")
        self.arrival_time = arrival_time
        self.scan_type = scan_type
        self.scan_id = scan_id

class Workstation(object):

    def __init__(self, env, total_servers, job_durations):
        self.store = simpy.Store(env)
        self.env = env
        self.out = None
        self.scan_arrived = 0
        self.server = simpy.Resource(env, total_servers)
        self.job_durations = job_durations

    def process(self, x):
        self.scan_arrived += 1
        job = x.jobtype
        pt = self.job_durations[job-1]()  # Call the job duration function for the specified job
        yield env.timeout(pt)

# Define the job duration functions outside of the Workstation class
def pt1():
    return np.random.normal(12, 2)/60

def pt2():
    return np.random.normal(15, 2)/60

def pt3():
    return np.random.normal(15, 3)/60

def pt4():
    return np.random.normal(18, 3)/60

# Define the job duration functions for each workstation
ws1_job_durations = [pt1, pt2, pt3]
ws2_job_durations = [pt1, None, pt3, pt4]
ws3_job_durations = [pt1, pt2, pt3]
ws4_job_durations = [None, pt2, pt3, pt4]
ws5_job_durations = [pt1, None, pt3, pt4]

# Create instances of the Workstation class with a loop
workstations = []
for i, job_durations, nr_servers in zip(range(1, 6), [ws1_job_durations, ws2_job_durations, ws3_job_durations, ws4_job_durations, ws5_job_durations], nr_servers_list):
    workstation = Workstation(env, nr_servers, job_durations)
    workstation.name = f"WS{i}"
    workstations.append(workstation)


class System(object):

    def __init__(self, env, source, interarrival, jobtype, file, delay=0):
        self.env = env
        self.source = source
        self.interarrival = interarrival
        self.jobtype = jobtype
        self.file = file
        self.delay = delay
        self.out = None
        self.total_scans = 0
        self.action = env.process(self.scan_arrivals_departures())

    def scan_arrivals_departures(self):
        yield self.env.timeout(self.delay)
        while rscans.total_scans + dscans.total_scans + 1 < N:  # STOP CRITERION at 1000 scans
            yield self.env.timeout(self.interarrival())  # Note point in time at which the scan arrives
            self.total_scans += 1  # Increment total scans by 1
            s = Scan(self.env.now, self.jobtype(), self.total_scans)  # Assign the scan its identity using Scan class

            self.file.write(
                'NEW SCAN (' + str(s.id) + '); SOURCE (' + str(self.source) + '); TIME (' + str(self.env.now) + ')')
            self.file.write('\n')

            env.process(wsArrival_wsDeparture_systemDeparture(env, s,
                                                              self))  # Let the scan run through the required ws and leave


def wsArrival_wsDeparture_systemDeparture(env, s, self):
    if s.jobtype == 1:
        with ws3.server.request() as request:  # Request a free server
            yield request  # If they one is available, the scan is assigned
            if ws3.server.count < 2:
                ws3.start = env.now
            self.file.write('ARRIVE WS (3); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws3.process(s))  # The scan is examined
            self.file.write(
                'DEPARTURE WS (3); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws3.server.count < 1:
            ws3.ut_t.append(env.now - ws3.start)  # If none are available, the waiting time is recorded

        with ws1.server.request() as request:  # It moves on to the next ws in line
            yield request
            if ws1.server.count < 2:
                ws1.start = env.now
            self.file.write('ARRIVE WS (1); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws1.process(s))
            self.file.write(
                'DEPARTURE WS (1); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws1.server.count < 1:
            ws1.ut_t.append(env.now - ws1.start)

        with ws2.server.request() as request:
            yield request
            if ws2.server.count < 2:
                ws2.start = env.now
            self.file.write('ARRIVE WS (2); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws2.process(s))
            self.file.write(
                'DEPARTURE WS (2); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws2.server.count < 1:
            ws2.ut_t.append(env.now - ws2.start)

        with ws5.server.request() as request:
            yield request
            if ws5.server.count < 2:
                ws5.start = env.now
            self.file.write('ARRIVE WS (5); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws5.process(s))
            self.out.queue(s)  # All the waiting line information from that particular scan gets stored
            self.file.write(
                'DEPARTURE WS (5); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws5.server.count < 1:
            ws5.ut_t.append(env.now - ws5.start)

    if s.jobtype == 2:
        with ws4.server.request() as request:
            yield request
            if ws4.server.count < 2:
                ws4.start = env.now
            self.file.write('ARRIVE WS (4); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws4.process(s))
            self.file.write(
                'DEPARTURE WS (4); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws4.server.count < 1:
            ws4.ut_t.append(env.now - ws4.start)

        with ws1.server.request() as request:
            yield request
            if ws1.server.count < 2:
                ws1.start = env.now
            self.file.write('ARRIVE WS (1); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws1.process(s))
            self.file.write(
                'DEPARTURE WS (1); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws1.server.count < 1:
            ws1.ut_t.append(env.now - ws1.start)

        with ws3.server.request() as request:
            yield request
            if ws3.server.count < 2:
                ws3.start = env.now
            self.file.write('ARRIVE WS (3); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws3.process(s))
            self.out.queue(s)
            self.file.write(
                'DEPARTURE WS (3); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws3.server.count < 1:
            ws3.ut_t.append(env.now - ws3.start)

    if s.jobtype == 3:
        with ws2.server.request() as request:
            yield request
            if ws2.server.count < 2:
                ws2.start = env.now
            self.file.write('ARRIVE WS (2); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws2.process(s))
            self.file.write(
                'DEPARTURE WS (2); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws2.server.count < 1:
            ws2.ut_t.append(env.now - ws2.start)

        with ws5.server.request() as request:
            yield request
            if ws5.server.count < 2:
                ws5.start = env.now
            self.file.write('ARRIVE WS (5); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws5.process(s))
            self.file.write(
                'DEPARTURE WS (5); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws5.server.count < 1:
            ws5.ut_t.append(env.now - ws5.start)

        with ws1.server.request() as request:
            yield request
            if ws1.server.count < 2:
                ws1.start = env.now
            self.file.write('ARRIVE WS (1); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws1.process(s))
            self.file.write(
                'DEPARTURE WS (1); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws1.server.count < 1:
            ws1.ut_t.append(env.now - ws1.start)

        with ws4.server.request() as request:
            yield request
            if ws4.server.count < 2:
                ws4.start = env.now
            self.file.write('ARRIVE WS (4); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws4.process(s))
            self.file.write(
                'DEPARTURE WS (4); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws4.server.count < 1:
            ws4.ut_t.append(env.now - ws4.start)

        with ws3.server.request() as request:
            yield request
            if ws3.server.count < 2:
                ws3.start = env.now
            self.file.write('ARRIVE WS (3); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws3.process(s))
            self.out.queue(s)
            self.file.write(
                'DEPARTURE WS (3); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws3.server.count < 1:
            ws3.ut_t.append(env.now - ws3.start)

    if s.jobtype == 4:
        with ws2.server.request() as request:
            yield request
            if ws2.server.count < 2:
                ws2.start = env.now
            self.file.write('ARRIVE WS (2); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws2.process(s))
            self.file.write(
                'DEPARTURE WS (2); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws2.server.count < 1:
            ws2.ut_t.append(env.now - ws2.start)

        with ws4.server.request() as request:
            yield request
            if ws4.server.count < 2:
                ws4.start = env.now
            self.file.write('ARRIVE WS (4); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws4.process(s))
            self.file.write(
                'DEPARTURE WS (4); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws4.server.count < 1:
            ws4.ut_t.append(env.now - ws4.start)

        with ws5.server.request() as request:
            yield request
            if ws5.server.count < 2:
                ws5.start = env.now
            self.file.write('ARRIVE WS (5); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                self.source) + ')')
            self.file.write('\n')
            yield env.process(ws5.process(s))
            self.out.queue(s)
            self.file.write(
                'DEPARTURE WS (5); TIME (' + str(self.env.now) + '); SCAN (' + str(s.id) + '); TYPE (' + str(
                    self.source) + ')')
            self.file.write('\n')
        if ws5.server.count < 1:
            ws5.ut_t.append(env.now - ws5.start)


class Queueing(object):
    def __init__(self, env):
        self.store = simpy.Store(env)
        self.env = env
        self.waits = []
        self.scan_arrived = 0

    def queue(self, scan):
        now = self.env.now
        self.waits.append(now - scan.time) #Store waiting time
        self.scan_arrived += 1
        
        
        
%%time
################################################################################################################################
data1 = open("RUN1.txt","w")
summary1 = open("STATS1.txt","w")
#data2 = open("RUN2.txt","w")
#summary2 = open("STATS2.txt","w")
#data3 = open("RUN3.txt","w")
#summary3 = open("STATS3.txt","w")
#data4 = open("RUN4.txt","w")
#summary4 = open("STATS4.txt","w")
#data5 = open("RUN5.txt","w")
#summary5 = open("STATS5.txt","w")
# Create the packet generators and sink

system = Queueing(env)
rscans = System(env, "RAD", InterArrival_R,  JobType_R, data1) 
dscans = System(env, "DD", InterArrival_D,  JobType_D, data1)
#rscans = System(env, "RAD", InterArrival_R,  JobType_R, data2) 
#dscans = System(env, "DD", InterArrival_D,  JobType_D, data2)
#rscans = System(env, "RAD", InterArrival_R,  JobType_R, data2) 
#dscans = System(env, "DD", InterArrival_D,  JobType_D, data3)
#rscans = System(env, "RAD", InterArrival_R,  JobType_R, data4)
#dscans = System(env, "DD", InterArrival_D,  JobType_D, data4)
#rscans = System(env, "RAD", InterArrival_R,  JobType_R, data5) 
#dscans = System(env, "DD", InterArrival_D,  JobType_D, data5)

rscans.out = system
dscans.out = system

env.run()

ct_r = sum(system.waits)/len(system.waits)
ut_r = sum(ws1.ut_t + ws2.ut_t + ws3.ut_t + ws4.ut_t + ws5.ut_t)/5/env.now
#system.waits
def create(summary):
    summary.write('Avg utilisation Station WS1: ')
    summary.write(str(round(((sum(ws1.ut_t)/env.now)*100),2)) + '%')
    summary.write('\n')
    summary.write('Avg utilisation Station WS2: ')
    summary.write(str(round(((sum(ws2.ut_t)/env.now)*100),2)) + '%')
    summary.write('\n')
    summary.write('Avg utilisation Station WS3: ')
    summary.write(str(round(((sum(ws3.ut_t)/env.now)*100),2)) + '%')
    summary.write('\n')
    summary.write('Avg utilisation Station WS4: ')
    summary.write(str(round(((sum(ws4.ut_t)/env.now)*100),2)) + '%')
    summary.write('\n')
    summary.write('Avg utilisation Station WS5: ')
    summary.write(str(round(((sum(ws5.ut_t)/env.now)*100),2)) + '%')
    summary.write('\n')
    summary.write('\n')
    summary.write('Overall avg utilisation: ' + str(round(ut_r*100,2)) + '%')
    summary.write('\n')
    summary.write('\n')
    summary.write('Average cycle time: ' + str(sum(system.waits)/len(system.waits)) + '\n')
    summary.write('Processing time: ' + str(env.now) +'\n') # Is around 300, but running mulitple times keeps summing up
    summary.write('\n')
    summary.write('Objective function: ct - 10p = ' + str(ct_r - 10*ut_r))
    
create(summary1)
#create(summary2)
#create(summary3)
#create(summary4)
#create(summary5)

## !!!! For some reason, the block needs to be run twice for the output to appear in the summary txt
################################################################################################################################
